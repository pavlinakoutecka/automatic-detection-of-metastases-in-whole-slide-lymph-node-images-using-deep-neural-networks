"""
File:           make_patches.py
Author:         Pavlina Koutecka
Date:           29/02/2020
Description:    This file aims to generate given number of samples from normal or tumor region
                on the slide. These samples, called patches, are generated randomly from given
                region (specified by corresponding mask).

                This file can also detect extremely dark or light patches that are generated and
                save them to specific folder.
"""

import cv2
import openslide
import numpy as np

import sys
import pathlib
parent_path = str(pathlib.Path().absolute().parent)
sys.path.append(parent_path)
sys.path.append(parent_path + '/2_preprocessing_and_visualization')
import configuration as cfg
import utils
import make_masks


def create_patch(slide, coordinates, patch_path, patch_size, patch_level):
    """
    This function generates and stores patch of given size and given top left pixel position.

    :param slide: slide from which should be patches extracted
    :param coordinates: coordinates of the top left pixel in the level 0 reference frame
    :param patch_path: path to the directory, where should be created patch stored
    :param patch_size: size of the region
    :param patch_level: level to which should be the patch downsampled
    :return: None
    """

    patch = None

    try:
        patch = slide.read_region(coordinates, patch_level, (patch_size, patch_size))
        #   cv2.read_region PARAMETERS:
        #       > location (tuple) – (x, y) tuple giving the top left pixel in the level 0 reference frame
        #       > level (int) – the level number
        #       > size (tuple) – (width, height) tuple giving the region size
        patch = cv2.cvtColor(np.array(patch), cv2.COLOR_RGBA2RGB)

        # save patch
        if patch_path:
            cv2.imwrite(patch_path, patch)

    except Exception as e:  # if we cannot access chosen region (or some other error)
        print(e)

    return patch


def sample_normal_region(slide_path, xml_path, slide_name, patch_path, patch_mask_path, mask_level, patch_level, patch_size, number_of_patches, find_extreme):
    """
    This function extracts from chosen slide given number of patches of given size and level
    from non-tumor region. It also extracts segmentation mask of all the generated patches
    for the purpose of training the net.
    Masks are extracted at chosen level and after that resized to level on which should be patches
    generated. These masks should be only BW - blurry edges are sharpened using threshold value.

    :param slide_path: path to the .tif file of the slide
    :param xml_path: path to the .xml file of the slide
    :param slide_name: name of the slide
    :param patch_path: path to the directory, where should be the patches stored, 'None' if should not be the patches stored
    :param patch_mask_path: path to the directory, where should be the masks of the patches stored, 'None' if should not be the patches masks maskstored
    :param mask_level: level to which should be the slide mask downsampled
    :param patch_level: level to which should be the patch downsampled
    :param patch_size: size of the region
    :param number_of_patches: number of patches to be generated
    :param find_extreme: 'True' if should be found some extremal patches, 'False' otherwise
    :return: None
    """

    # initialize slide and store its name
    slide = openslide.OpenSlide(slide_path)  # open WSI

    # create mask of the non-tumor and tumor region
    if xml_path:  # if we samples tumor slide, we need to operate with its tumor mask and mask of non-tumor region
        normal_mask = make_masks.make_normal_mask(slide_path, xml_path, None, mask_level)
        tumor_mask = make_masks.make_tumor_mask(slide_path, xml_path, None, mask_level)
    else:  # otherwise, we need to generate empty tumor mask and operate with tissue region mask
        mask_width, mask_height = slide.level_dimensions[mask_level]  # get WSIs dimensions of level mask_level
        normal_mask = make_masks.make_tissue_region_mask(slide_path, xml_path, None, mask_level)
        tumor_mask = np.zeros((mask_height, mask_width))

    # get downsampling factors
    mask_level_factor = float(slide.level_downsamples[mask_level])  # factor of level mask_level (2**mask_level)
    patch_level_factor = float(slide.level_downsamples[patch_level])  # factor of level patch_level (2**patch_level)

    # find coordinates of the non-tumor region
    coordinates = cv2.findNonZero(normal_mask)

    # resize tumor mask to the same level as patches are generated by downsampling factor of level patch_level
    patch_width, patch_height = slide.level_dimensions[patch_level]  # get WSIs dimensions of level patch_level
    resized_tumor_mask = cv2.resize(tumor_mask, (patch_width, patch_height), interpolation=cv2.INTER_LINEAR)

    # prepare the seed for random generation of patches
    np.random.seed(cfg.hyperparameter.seed)

    # generate random patches of size patch_size
    for i in range(number_of_patches):

        utils.visualize_progress(i, number_of_patches)

        # Randomly point somewhere on the slide to get center pixel of new patch.
        # After that, subtract patch_size/2 from rescaled (to level 0) x and y
        # coordinates to get top left corner of the patch.
        index = np.random.randint(0, len(coordinates))
        top_left_corner = (int((coordinates[index][0][0] * mask_level_factor) - patch_size/2),
                           int((coordinates[index][0][1] * mask_level_factor) - patch_size/2))

        # store the patch only if needed
        if patch_path:
            full_patch_path = patch_path + slide_name.replace('.tif', '') + '__normal_patch_' + str(patch_size) + '_' + str(patch_level) + '_' + str(i) + '.png'
        else:
            full_patch_path = None

        # create tissue patch starting at position top_left_corner of size patch_size
        patch = create_patch(slide, top_left_corner, full_patch_path, patch_size, patch_level)

        # create patch mask of tumor region starting at position top_left_corner (rescaled to level patch_level) of size patch_size
        resized_tumor_mask_ROI = resized_tumor_mask[
                                 int(top_left_corner[1] / patch_level_factor):int(top_left_corner[1] / patch_level_factor + patch_size),
                                 int(top_left_corner[0] / patch_level_factor):int(top_left_corner[0] / patch_level_factor + patch_size)]
        # these patch masks should be only BW --> blurry edges are sharpened using threshold value
        _, threshold = cv2.threshold(resized_tumor_mask_ROI, 150, 255, cv2.THRESH_BINARY)
        resized_tumor_mask_ROI[threshold == 255] = 255
        resized_tumor_mask_ROI[threshold == 0] = 0

        # store the patches mask only if needed
        if patch_mask_path:
            full_mask_path = patch_mask_path + slide_name.replace('.tif', '') + '__normal_patch_mask_' + str(patch_size) + '_' + str(patch_level) + '_' + str(i) + '.png'
            cv2.imwrite(full_mask_path, resized_tumor_mask_ROI)

        # check if this patch is extremely light or dark and save it
        if find_extreme:
            find_extreme_patches(patch, cfg.path.extreme_patches)


def sample_tumor_region(slide_path, xml_path, slide_name, patch_path, patch_mask_path,  mask_level, patch_level, patch_size, number_of_patches, find_extreme):
    """
    This function extracts from chosen slide given number of patches of given size and level
    from tumor region. It also extracts segmentation mask of all the generated patches
    for the purpose of training the net.
    Masks are extracted at chosen level and after that resized to level on which should be patches
    generated. These masks should be only BW - blurry edges are sharpened using threshold value.

    :param slide_path: path to the .tif file of the slide
    :param xml_path: path to the .xml file of the slide
    :param slide_name: name of the slide
    :param patch_path: path to the directory, where should be patches stored, 'None' if should not be the patches stored
    :param patch_mask_path: path to the directory, where should be masks of the patches stored, 'None' if should not be the patches masks maskstored
    :param mask_level: level to which should be the slide mask downsampled
    :param patch_level: level to which should be the patch downsampled
    :param patch_size: size of the region
    :param number_of_patches: number of patches to be generated
    :param find_extreme: 'True' if should be found some extremal patches, 'False' otherwise
    :return: None
    """

    # initialize slide
    slide = openslide.OpenSlide(slide_path)  # open WSI

    # create mask of the tumor region
    tumor_mask = make_masks.make_tumor_mask(slide_path, xml_path, None, mask_level)

    # get downsampling factor
    mask_level_factor = float(slide.level_downsamples[mask_level])  # factor of level mask_level (2**mask_level)
    patch_level_factor = float(slide.level_downsamples[patch_level])  # factor of level patch_level (2**patch_level)

    # find coordinates of the tumor region
    coordinates = cv2.findNonZero(tumor_mask)

    # resize tumor mask to the same level as patches are generated by downsampling factor of level patch_level
    patch_width, patch_height = slide.level_dimensions[patch_level]  # get WSIs dimensions of level patch_level
    resized_tumor_mask = cv2.resize(tumor_mask, (patch_width, patch_height), interpolation=cv2.INTER_LINEAR)

    # prepare the seed for random generation of patches
    np.random.seed(cfg.hyperparameter.seed)

    # generate random patches of size patch_size
    for i in range(number_of_patches):

        utils.visualize_progress(i, number_of_patches)

        # Randomly point somewhere on the slide to get center pixel of new patch.
        # After that, subtract patch_size/2 from rescaled (to level 0) x and y
        # coordinates to get top left corner of the patch.
        index = np.random.randint(0, len(coordinates))
        top_left_corner = (int((coordinates[index][0][0] * mask_level_factor) - patch_size/2),
                           int((coordinates[index][0][1] * mask_level_factor) - patch_size/2))

        # store the patch only if needed
        if patch_path:
            full_patch_path = patch_path + slide_name.replace('.tif', '') + '__tumor_patch_' + str(patch_size) + '_' + str(patch_level) + '_' + str(i) + '.png'
        else:
            full_patch_path = None

        # create tissue patch starting at position top_left_corner of size patch_size
        patch = create_patch(slide, top_left_corner, full_patch_path, patch_size, patch_level)

        # create patch mask of tumor region starting at position top_left_corner (rescaled to level patch_level) of size patch_size
        resized_tumor_mask_ROI = resized_tumor_mask[
                                 int(top_left_corner[1] / patch_level_factor):int(top_left_corner[1] / patch_level_factor + patch_size),
                                 int(top_left_corner[0] / patch_level_factor):int(top_left_corner[0] / patch_level_factor + patch_size)]
        # these patch masks should be only BW --> blurry edges are sharpened using threshold value
        _, threshold = cv2.threshold(resized_tumor_mask_ROI, 150, 255, cv2.THRESH_BINARY)
        resized_tumor_mask_ROI[threshold == 255] = 255
        resized_tumor_mask_ROI[threshold == 0] = 0

        # store the patches mask only if needed
        if patch_mask_path:
            full_mask_path = patch_mask_path + slide_name.replace('.tif', '') + '__tumor_patch_mask_' + str(patch_size) + '_' + str(patch_level) + '_' + str(i) + '.png'
            cv2.imwrite(full_mask_path, resized_tumor_mask_ROI)

        # check if this patch is extremely light or dark and save it
        if find_extreme:
            find_extreme_patches(patch, cfg.path.extreme_patches + slide_name.replace('.tif', '') + f'_patch{i}.png')


def find_extreme_patches(patch, patch_path):
    """
    This function finds extremely light or dark patches.

    :param patch: patch to be investigated
    :param patch_path: path to the directory where should be stored
    :return: None
    """

    # find extremely light or dark patches (to give example in thesis)
    average_color = patch.mean(axis=0).mean(axis=0)
    check_white = average_color[0] > 230 and average_color[1] > 230 and average_color[2] > 230
    check_black = average_color[0] < 60 and average_color[1] < 60 and average_color[2] < 60

    # save extremely light patch
    if patch_path and check_white:
        cv2.imwrite(patch_path.replace('.png', '_extreme_white.png'), patch)

    # save extremely dark patch
    if patch_path and check_black:
        cv2.imwrite(patch_path.replace('.png', '_extreme_black.png'), patch)
